// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "message.proto" (syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Position
 */
export interface Position {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message Rotation
 */
export interface Rotation {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
    /**
     * @generated from protobuf field: float w = 4;
     */
    w: number;
}
/**
 * @generated from protobuf message Scale
 */
export interface Scale {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message Color
 */
export interface Color {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message SpatialInfo
 */
export interface SpatialInfo {
    /**
     * @generated from protobuf field: Position position = 1;
     */
    position?: Position;
    /**
     * @generated from protobuf field: Rotation rotation = 2;
     */
    rotation?: Rotation;
    /**
     * @generated from protobuf field: Scale scale = 3;
     */
    scale?: Scale;
}
/**
 * @generated from protobuf message Frustum
 */
export interface Frustum {
    /**
     * @generated from protobuf field: Position n1 = 1;
     */
    n1?: Position;
    /**
     * @generated from protobuf field: Position n2 = 2;
     */
    n2?: Position;
    /**
     * @generated from protobuf field: Position n3 = 3;
     */
    n3?: Position;
    /**
     * @generated from protobuf field: Position n4 = 4;
     */
    n4?: Position;
    /**
     * @generated from protobuf field: Position f1 = 5;
     */
    f1?: Position;
    /**
     * @generated from protobuf field: Position f2 = 6;
     */
    f2?: Position;
    /**
     * @generated from protobuf field: Position f3 = 7;
     */
    f3?: Position;
    /**
     * @generated from protobuf field: Position f4 = 8;
     */
    f4?: Position;
}
/**
 * @generated from protobuf message UserInfo
 */
export interface UserInfo {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: UserInfo.ClientType type = 2;
     */
    type: UserInfo_ClientType;
    /**
     * @generated from protobuf field: string roomId = 3;
     */
    roomId: string;
    /**
     * @generated from protobuf field: SpatialInfo headSpatialInfo = 4;
     */
    headSpatialInfo?: SpatialInfo;
    /**
     * @generated from protobuf field: SpatialInfo leftControllerSpatialInfo = 5;
     */
    leftControllerSpatialInfo?: SpatialInfo;
    /**
     * @generated from protobuf field: SpatialInfo rightControllerSpatialInfo = 6;
     */
    rightControllerSpatialInfo?: SpatialInfo;
    /**
     * @generated from protobuf field: Frustum frustum = 7;
     */
    frustum?: Frustum;
    /**
     * @generated from protobuf field: string documentId = 8;
     */
    documentId: string;
    /**
     * @generated from protobuf field: string dataset = 9;
     */
    dataset: string;
    /**
     * @generated from protobuf field: SpatialInfo graphSpatialInfo = 10;
     */
    graphSpatialInfo?: SpatialInfo;
    /**
     * @generated from protobuf field: SpatialInfo documentPanelSpatialInfo = 11;
     */
    documentPanelSpatialInfo?: SpatialInfo;
    /**
     * @generated from protobuf field: repeated string nearCursorNodeIds = 12;
     */
    nearCursorNodeIds: string[];
    /**
     * @generated from protobuf field: repeated float nearCursorNodeWeights = 13;
     */
    nearCursorNodeWeights: number[];
    /**
     * @generated from protobuf field: bool override = 14;
     */
    override: boolean;
    /**
     * @generated from protobuf field: string headTowardsObject = 15;
     */
    headTowardsObject: string;
    /**
     * @generated from protobuf field: optional SpatialInfo simulatedPCPose = 16;
     */
    simulatedPCPose?: SpatialInfo;
}
/**
 * @generated from protobuf enum UserInfo.ClientType
 */
export enum UserInfo_ClientType {
    /**
     * @generated from protobuf enum value: DESKTOP = 0;
     */
    DESKTOP = 0,
    /**
     * @generated from protobuf enum value: VR = 1;
     */
    VR = 1
}
/**
 * @generated from protobuf message UserList
 */
export interface UserList {
    /**
     * @generated from protobuf field: repeated UserInfo users = 1;
     */
    users: UserInfo[];
}
/**
 * @generated from protobuf message Node
 */
export interface Node {
    /**
     * @generated from protobuf field: string roomId = 1;
     */
    roomId: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: SpatialInfo spatialInfo = 3;
     */
    spatialInfo?: SpatialInfo;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: string data = 5;
     */
    data: string;
    /**
     * @generated from protobuf field: string createdFrom = 6;
     */
    createdFrom: string;
    /**
     * @generated from protobuf field: string createdBy = 7;
     */
    createdBy: string;
    /**
     * @generated from protobuf field: repeated string highlightedBy = 8;
     */
    highlightedBy: string[];
    /**
     * @generated from protobuf field: repeated DocumentReference references = 9;
     */
    references: DocumentReference[];
    /**
     * @generated from protobuf field: string updatedBy = 10;
     */
    updatedBy: string;
    /**
     * @generated from protobuf field: string dataType = 11;
     */
    dataType: string;
    /**
     * @generated from protobuf field: UserKey userKey = 12;
     */
    userKey?: UserKey;
}
/**
 * @generated from protobuf message DocumentReference
 */
export interface DocumentReference {
    /**
     * @generated from protobuf field: string docId = 1;
     */
    docId: string;
    /**
     * @generated from protobuf field: int32 startIndex = 2;
     */
    startIndex: number;
    /**
     * @generated from protobuf field: int32 endIndex = 3;
     */
    endIndex: number;
    /**
     * @generated from protobuf field: string createdBy = 4;
     */
    createdBy: string;
}
/**
 * @generated from protobuf message NodeSpatialInfo
 */
export interface NodeSpatialInfo {
    /**
     * @generated from protobuf field: string roomId = 1;
     */
    roomId: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: SpatialInfo spatialInfo = 3;
     */
    spatialInfo?: SpatialInfo;
}
/**
 * @generated from protobuf message NodeList
 */
export interface NodeList {
    /**
     * @generated from protobuf field: repeated NodeSpatialInfo SpatialInfos = 1 [json_name = "SpatialInfos"];
     */
    spatialInfos: NodeSpatialInfo[];
    /**
     * @generated from protobuf field: UserKey userKey = 2;
     */
    userKey?: UserKey;
}
/**
 * @generated from protobuf message Link
 */
export interface Link {
    /**
     * @generated from protobuf field: int32 source = 1;
     */
    source: number;
    /**
     * @generated from protobuf field: int32 target = 2;
     */
    target: number;
    /**
     * @generated from protobuf field: string id = 3;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: string data = 5;
     */
    data: string;
    /**
     * @generated from protobuf field: string roomId = 6;
     */
    roomId: string;
    /**
     * @generated from protobuf field: string createdFrom = 7;
     */
    createdFrom: string;
    /**
     * @generated from protobuf field: string createdBy = 8;
     */
    createdBy: string;
    /**
     * @generated from protobuf field: string updatedBy = 9;
     */
    updatedBy: string;
    /**
     * @generated from protobuf field: UserKey userKey = 10;
     */
    userKey?: UserKey;
}
/**
 * @generated from protobuf message LinkList
 */
export interface LinkList {
    /**
     * @generated from protobuf field: repeated Link links = 1;
     */
    links: Link[];
}
/**
 * @generated from protobuf message GraphViewData
 */
export interface GraphViewData {
    /**
     * @generated from protobuf field: repeated Node nodes = 1;
     */
    nodes: Node[];
    /**
     * @generated from protobuf field: repeated Link links = 2;
     */
    links: Link[];
    /**
     * @generated from protobuf field: SpatialInfo spatialInfo = 3;
     */
    spatialInfo?: SpatialInfo;
}
/**
 * @generated from protobuf message ClientActions
 */
export interface ClientActions {
    /**
     * @generated from protobuf field: UserKey userKey = 1;
     */
    userKey?: UserKey;
    /**
     * @generated from protobuf field: repeated int32 clickedNodes = 2;
     */
    clickedNodes: number[];
    /**
     * @generated from protobuf field: repeated int32 hoveredNodes = 3;
     */
    hoveredNodes: number[];
    /**
     * @generated from protobuf field: string fromView = 5;
     */
    fromView: string;
}
/**
 * @generated from protobuf message TrackerInfo
 */
export interface TrackerInfo {
    /**
     * @generated from protobuf field: string trackerId = 1;
     */
    trackerId: string;
    /**
     * @generated from protobuf field: Position position = 2;
     */
    position?: Position;
    /**
     * @generated from protobuf field: Rotation rotation = 3;
     */
    rotation?: Rotation;
}
/**
 * @generated from protobuf message HighlightedList
 */
export interface HighlightedList {
    /**
     * @generated from protobuf field: repeated int32 highlighted = 1;
     */
    highlighted: number[];
}
/**
 * @generated from protobuf message ServerNodesStatus
 */
export interface ServerNodesStatus {
    /**
     * @generated from protobuf field: map<string, HighlightedList> hightlighted = 1;
     */
    hightlighted: {
        [key: string]: HighlightedList;
    };
}
/**
 * @generated from protobuf message EmptyMessage
 */
export interface EmptyMessage {
    /**
     * @generated from protobuf field: bool isRecieved = 1;
     */
    isRecieved: boolean;
}
/**
 * @generated from protobuf message InitialRequest
 */
export interface InitialRequest {
    /**
     * @generated from protobuf field: InitialRequest.ClientViewType RequestedViewType = 1 [json_name = "RequestedViewType"];
     */
    requestedViewType: InitialRequest_ClientViewType;
    /**
     * @generated from protobuf field: UserKey userKey = 2;
     */
    userKey?: UserKey;
}
/**
 * @generated from protobuf enum InitialRequest.ClientViewType
 */
export enum InitialRequest_ClientViewType {
    /**
     * @generated from protobuf enum value: VIEW_2D = 0;
     */
    VIEW_2D = 0,
    /**
     * @generated from protobuf enum value: VIEW_3D = 1;
     */
    VIEW_3D = 1
}
/**
 * @generated from protobuf message InitialGraphData
 */
export interface InitialGraphData {
    /**
     * @generated from protobuf field: GraphViewData graphViewData = 1;
     */
    graphViewData?: GraphViewData;
    /**
     * @generated from protobuf field: ServerNodesStatus nodesStatus = 2;
     */
    nodesStatus?: ServerNodesStatus;
}
/**
 * @generated from protobuf message Room
 */
export interface Room {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: repeated UserInfo users = 2;
     */
    users: UserInfo[];
}
/**
 * @generated from protobuf message RoomList
 */
export interface RoomList {
    /**
     * @generated from protobuf field: repeated Room rooms = 1;
     */
    rooms: Room[];
}
/**
 * @generated from protobuf message JoinResponse
 */
export interface JoinResponse {
    /**
     * @generated from protobuf field: string error = 1;
     */
    error: string;
    /**
     * @generated from protobuf field: string msg = 2;
     */
    msg: string;
}
/**
 * @generated from protobuf message ServerGraphStatus
 */
export interface ServerGraphStatus {
    /**
     * @generated from protobuf field: ServerNodesStatus nodesStatus = 1;
     */
    nodesStatus?: ServerNodesStatus;
    /**
     * @generated from protobuf field: InitialGraphData initialGraphData = 2;
     */
    initialGraphData?: InitialGraphData;
}
/**
 * @generated from protobuf message Document
 */
export interface Document {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: string date = 3;
     */
    date: string;
    /**
     * @generated from protobuf field: string author = 4;
     */
    author: string;
    /**
     * @generated from protobuf field: string content = 5;
     */
    content: string;
    /**
     * @generated from protobuf field: string fileName = 6;
     */
    fileName: string;
}
/**
 * @generated from protobuf message DocumentList
 */
export interface DocumentList {
    /**
     * @generated from protobuf field: repeated Document documents = 1;
     */
    documents: Document[];
}
/**
 * @generated from protobuf message IdList
 */
export interface IdList {
    /**
     * @generated from protobuf field: repeated string ids = 1;
     */
    ids: string[];
}
/**
 * @generated from protobuf message DocumentState
 */
export interface DocumentState {
    /**
     * @generated from protobuf field: map<string, IdList> documentStates = 1;
     */
    documentStates: {
        [key: string]: IdList;
    };
}
/**
 * @generated from protobuf message RequestById
 */
export interface RequestById {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: UserKey userKey = 2;
     */
    userKey?: UserKey;
}
/**
 * @generated from protobuf message BoardcastMessage
 */
export interface BoardcastMessage {
    /**
     * @generated from protobuf field: string msg = 1;
     */
    msg: string;
    /**
     * @generated from protobuf field: UserKey userKey = 2;
     */
    userKey?: UserKey;
    /**
     * @generated from protobuf field: BoardcastMessage.Action action = 3;
     */
    action: BoardcastMessage_Action;
}
/**
 * @generated from protobuf enum BoardcastMessage.Action
 */
export enum BoardcastMessage_Action {
    /**
     * @generated from protobuf enum value: HIGHLIGHT = 0;
     */
    HIGHLIGHT = 0
}
/**
 * @generated from protobuf message ReplayMessage
 */
export interface ReplayMessage {
    /**
     * @generated from protobuf field: string msg = 1;
     */
    msg: string;
    /**
     * @generated from protobuf field: UserKey userKey = 2;
     */
    userKey?: UserKey;
}
/**
 * @generated from protobuf message ReplayRecord
 */
export interface ReplayRecord {
    /**
     * @generated from protobuf field: UserKey userKey = 1;
     */
    userKey?: UserKey;
}
/**
 * @generated from protobuf message ReplayList
 */
export interface ReplayList {
    /**
     * @generated from protobuf field: repeated ReplayRecord records = 1;
     */
    records: ReplayRecord[];
}
/**
 * @generated from protobuf message WebRTCOffer
 */
export interface WebRTCOffer {
    /**
     * @generated from protobuf field: string data = 1;
     */
    data: string;
}
/**
 * @generated from protobuf message WebRTCAnswer
 */
export interface WebRTCAnswer {
    /**
     * @generated from protobuf field: string data = 1;
     */
    data: string;
}
/**
 * @generated from protobuf message TimelineData
 */
export interface TimelineData {
    /**
     * @generated from protobuf field: map<string, IdList> data = 1;
     */
    data: {
        [key: string]: IdList;
    };
}
/**
 * @generated from protobuf message UserKey
 */
export interface UserKey {
    /**
     * @generated from protobuf field: string userId = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string;
    /**
     * @generated from protobuf field: UserInfo.ClientType type = 3;
     */
    type: UserInfo_ClientType;
    /**
     * @generated from protobuf field: InitialRequest.ClientViewType viewType = 4;
     */
    viewType: InitialRequest_ClientViewType;
}
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("Position", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = { x: 0, y: 0, z: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rotation$Type extends MessageType<Rotation> {
    constructor() {
        super("Rotation", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Rotation>): Rotation {
        const message = { x: 0, y: 0, z: 0, w: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Rotation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rotation): Rotation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                case /* float w */ 4:
                    message.w = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rotation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        /* float w = 4; */
        if (message.w !== 0)
            writer.tag(4, WireType.Bit32).float(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Rotation
 */
export const Rotation = new Rotation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Scale$Type extends MessageType<Scale> {
    constructor() {
        super("Scale", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Scale>): Scale {
        const message = { x: 0, y: 0, z: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Scale>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Scale): Scale {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Scale, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Scale
 */
export const Scale = new Scale$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Color$Type extends MessageType<Color> {
    constructor() {
        super("Color", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Color>): Color {
        const message = { x: 0, y: 0, z: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Color>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Color): Color {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Color, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Color
 */
export const Color = new Color$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpatialInfo$Type extends MessageType<SpatialInfo> {
    constructor() {
        super("SpatialInfo", [
            { no: 1, name: "position", kind: "message", T: () => Position },
            { no: 2, name: "rotation", kind: "message", T: () => Rotation },
            { no: 3, name: "scale", kind: "message", T: () => Scale }
        ]);
    }
    create(value?: PartialMessage<SpatialInfo>): SpatialInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpatialInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpatialInfo): SpatialInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Position position */ 1:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* Rotation rotation */ 2:
                    message.rotation = Rotation.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                case /* Scale scale */ 3:
                    message.scale = Scale.internalBinaryRead(reader, reader.uint32(), options, message.scale);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpatialInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Position position = 1; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Rotation rotation = 2; */
        if (message.rotation)
            Rotation.internalBinaryWrite(message.rotation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Scale scale = 3; */
        if (message.scale)
            Scale.internalBinaryWrite(message.scale, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SpatialInfo
 */
export const SpatialInfo = new SpatialInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Frustum$Type extends MessageType<Frustum> {
    constructor() {
        super("Frustum", [
            { no: 1, name: "n1", kind: "message", T: () => Position },
            { no: 2, name: "n2", kind: "message", T: () => Position },
            { no: 3, name: "n3", kind: "message", T: () => Position },
            { no: 4, name: "n4", kind: "message", T: () => Position },
            { no: 5, name: "f1", kind: "message", T: () => Position },
            { no: 6, name: "f2", kind: "message", T: () => Position },
            { no: 7, name: "f3", kind: "message", T: () => Position },
            { no: 8, name: "f4", kind: "message", T: () => Position }
        ]);
    }
    create(value?: PartialMessage<Frustum>): Frustum {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Frustum>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Frustum): Frustum {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Position n1 */ 1:
                    message.n1 = Position.internalBinaryRead(reader, reader.uint32(), options, message.n1);
                    break;
                case /* Position n2 */ 2:
                    message.n2 = Position.internalBinaryRead(reader, reader.uint32(), options, message.n2);
                    break;
                case /* Position n3 */ 3:
                    message.n3 = Position.internalBinaryRead(reader, reader.uint32(), options, message.n3);
                    break;
                case /* Position n4 */ 4:
                    message.n4 = Position.internalBinaryRead(reader, reader.uint32(), options, message.n4);
                    break;
                case /* Position f1 */ 5:
                    message.f1 = Position.internalBinaryRead(reader, reader.uint32(), options, message.f1);
                    break;
                case /* Position f2 */ 6:
                    message.f2 = Position.internalBinaryRead(reader, reader.uint32(), options, message.f2);
                    break;
                case /* Position f3 */ 7:
                    message.f3 = Position.internalBinaryRead(reader, reader.uint32(), options, message.f3);
                    break;
                case /* Position f4 */ 8:
                    message.f4 = Position.internalBinaryRead(reader, reader.uint32(), options, message.f4);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Frustum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Position n1 = 1; */
        if (message.n1)
            Position.internalBinaryWrite(message.n1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Position n2 = 2; */
        if (message.n2)
            Position.internalBinaryWrite(message.n2, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Position n3 = 3; */
        if (message.n3)
            Position.internalBinaryWrite(message.n3, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Position n4 = 4; */
        if (message.n4)
            Position.internalBinaryWrite(message.n4, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* Position f1 = 5; */
        if (message.f1)
            Position.internalBinaryWrite(message.f1, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Position f2 = 6; */
        if (message.f2)
            Position.internalBinaryWrite(message.f2, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* Position f3 = 7; */
        if (message.f3)
            Position.internalBinaryWrite(message.f3, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* Position f4 = 8; */
        if (message.f4)
            Position.internalBinaryWrite(message.f4, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Frustum
 */
export const Frustum = new Frustum$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserInfo$Type extends MessageType<UserInfo> {
    constructor() {
        super("UserInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["UserInfo.ClientType", UserInfo_ClientType] },
            { no: 3, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "headSpatialInfo", kind: "message", T: () => SpatialInfo },
            { no: 5, name: "leftControllerSpatialInfo", kind: "message", T: () => SpatialInfo },
            { no: 6, name: "rightControllerSpatialInfo", kind: "message", T: () => SpatialInfo },
            { no: 7, name: "frustum", kind: "message", T: () => Frustum },
            { no: 8, name: "documentId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "dataset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "graphSpatialInfo", kind: "message", T: () => SpatialInfo },
            { no: 11, name: "documentPanelSpatialInfo", kind: "message", T: () => SpatialInfo },
            { no: 12, name: "nearCursorNodeIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "nearCursorNodeWeights", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "override", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "headTowardsObject", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "simulatedPCPose", kind: "message", T: () => SpatialInfo }
        ]);
    }
    create(value?: PartialMessage<UserInfo>): UserInfo {
        const message = { id: "", type: 0, roomId: "", documentId: "", dataset: "", nearCursorNodeIds: [], nearCursorNodeWeights: [], override: false, headTowardsObject: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserInfo): UserInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* UserInfo.ClientType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string roomId */ 3:
                    message.roomId = reader.string();
                    break;
                case /* SpatialInfo headSpatialInfo */ 4:
                    message.headSpatialInfo = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.headSpatialInfo);
                    break;
                case /* SpatialInfo leftControllerSpatialInfo */ 5:
                    message.leftControllerSpatialInfo = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.leftControllerSpatialInfo);
                    break;
                case /* SpatialInfo rightControllerSpatialInfo */ 6:
                    message.rightControllerSpatialInfo = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.rightControllerSpatialInfo);
                    break;
                case /* Frustum frustum */ 7:
                    message.frustum = Frustum.internalBinaryRead(reader, reader.uint32(), options, message.frustum);
                    break;
                case /* string documentId */ 8:
                    message.documentId = reader.string();
                    break;
                case /* string dataset */ 9:
                    message.dataset = reader.string();
                    break;
                case /* SpatialInfo graphSpatialInfo */ 10:
                    message.graphSpatialInfo = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.graphSpatialInfo);
                    break;
                case /* SpatialInfo documentPanelSpatialInfo */ 11:
                    message.documentPanelSpatialInfo = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.documentPanelSpatialInfo);
                    break;
                case /* repeated string nearCursorNodeIds */ 12:
                    message.nearCursorNodeIds.push(reader.string());
                    break;
                case /* repeated float nearCursorNodeWeights */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.nearCursorNodeWeights.push(reader.float());
                    else
                        message.nearCursorNodeWeights.push(reader.float());
                    break;
                case /* bool override */ 14:
                    message.override = reader.bool();
                    break;
                case /* string headTowardsObject */ 15:
                    message.headTowardsObject = reader.string();
                    break;
                case /* optional SpatialInfo simulatedPCPose */ 16:
                    message.simulatedPCPose = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.simulatedPCPose);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* UserInfo.ClientType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string roomId = 3; */
        if (message.roomId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.roomId);
        /* SpatialInfo headSpatialInfo = 4; */
        if (message.headSpatialInfo)
            SpatialInfo.internalBinaryWrite(message.headSpatialInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* SpatialInfo leftControllerSpatialInfo = 5; */
        if (message.leftControllerSpatialInfo)
            SpatialInfo.internalBinaryWrite(message.leftControllerSpatialInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* SpatialInfo rightControllerSpatialInfo = 6; */
        if (message.rightControllerSpatialInfo)
            SpatialInfo.internalBinaryWrite(message.rightControllerSpatialInfo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* Frustum frustum = 7; */
        if (message.frustum)
            Frustum.internalBinaryWrite(message.frustum, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string documentId = 8; */
        if (message.documentId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.documentId);
        /* string dataset = 9; */
        if (message.dataset !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.dataset);
        /* SpatialInfo graphSpatialInfo = 10; */
        if (message.graphSpatialInfo)
            SpatialInfo.internalBinaryWrite(message.graphSpatialInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* SpatialInfo documentPanelSpatialInfo = 11; */
        if (message.documentPanelSpatialInfo)
            SpatialInfo.internalBinaryWrite(message.documentPanelSpatialInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated string nearCursorNodeIds = 12; */
        for (let i = 0; i < message.nearCursorNodeIds.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.nearCursorNodeIds[i]);
        /* repeated float nearCursorNodeWeights = 13; */
        if (message.nearCursorNodeWeights.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.nearCursorNodeWeights.length; i++)
                writer.float(message.nearCursorNodeWeights[i]);
            writer.join();
        }
        /* bool override = 14; */
        if (message.override !== false)
            writer.tag(14, WireType.Varint).bool(message.override);
        /* string headTowardsObject = 15; */
        if (message.headTowardsObject !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.headTowardsObject);
        /* optional SpatialInfo simulatedPCPose = 16; */
        if (message.simulatedPCPose)
            SpatialInfo.internalBinaryWrite(message.simulatedPCPose, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserInfo
 */
export const UserInfo = new UserInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserList$Type extends MessageType<UserList> {
    constructor() {
        super("UserList", [
            { no: 1, name: "users", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserInfo }
        ]);
    }
    create(value?: PartialMessage<UserList>): UserList {
        const message = { users: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserList): UserList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated UserInfo users */ 1:
                    message.users.push(UserInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated UserInfo users = 1; */
        for (let i = 0; i < message.users.length; i++)
            UserInfo.internalBinaryWrite(message.users[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserList
 */
export const UserList = new UserList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Node$Type extends MessageType<Node> {
    constructor() {
        super("Node", [
            { no: 1, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spatialInfo", kind: "message", T: () => SpatialInfo },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "createdFrom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "createdBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "highlightedBy", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "references", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentReference },
            { no: 10, name: "updatedBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "dataType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "userKey", kind: "message", T: () => UserKey }
        ]);
    }
    create(value?: PartialMessage<Node>): Node {
        const message = { roomId: "", id: "", name: "", data: "", createdFrom: "", createdBy: "", highlightedBy: [], references: [], updatedBy: "", dataType: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Node): Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string roomId */ 1:
                    message.roomId = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* SpatialInfo spatialInfo */ 3:
                    message.spatialInfo = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.spatialInfo);
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string data */ 5:
                    message.data = reader.string();
                    break;
                case /* string createdFrom */ 6:
                    message.createdFrom = reader.string();
                    break;
                case /* string createdBy */ 7:
                    message.createdBy = reader.string();
                    break;
                case /* repeated string highlightedBy */ 8:
                    message.highlightedBy.push(reader.string());
                    break;
                case /* repeated DocumentReference references */ 9:
                    message.references.push(DocumentReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string updatedBy */ 10:
                    message.updatedBy = reader.string();
                    break;
                case /* string dataType */ 11:
                    message.dataType = reader.string();
                    break;
                case /* UserKey userKey */ 12:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string roomId = 1; */
        if (message.roomId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.roomId);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* SpatialInfo spatialInfo = 3; */
        if (message.spatialInfo)
            SpatialInfo.internalBinaryWrite(message.spatialInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string data = 5; */
        if (message.data !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.data);
        /* string createdFrom = 6; */
        if (message.createdFrom !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.createdFrom);
        /* string createdBy = 7; */
        if (message.createdBy !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdBy);
        /* repeated string highlightedBy = 8; */
        for (let i = 0; i < message.highlightedBy.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.highlightedBy[i]);
        /* repeated DocumentReference references = 9; */
        for (let i = 0; i < message.references.length; i++)
            DocumentReference.internalBinaryWrite(message.references[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string updatedBy = 10; */
        if (message.updatedBy !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.updatedBy);
        /* string dataType = 11; */
        if (message.dataType !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.dataType);
        /* UserKey userKey = 12; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Node
 */
export const Node = new Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentReference$Type extends MessageType<DocumentReference> {
    constructor() {
        super("DocumentReference", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "startIndex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "endIndex", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "createdBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocumentReference>): DocumentReference {
        const message = { docId: "", startIndex: 0, endIndex: 0, createdBy: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DocumentReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentReference): DocumentReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* int32 startIndex */ 2:
                    message.startIndex = reader.int32();
                    break;
                case /* int32 endIndex */ 3:
                    message.endIndex = reader.int32();
                    break;
                case /* string createdBy */ 4:
                    message.createdBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* int32 startIndex = 2; */
        if (message.startIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.startIndex);
        /* int32 endIndex = 3; */
        if (message.endIndex !== 0)
            writer.tag(3, WireType.Varint).int32(message.endIndex);
        /* string createdBy = 4; */
        if (message.createdBy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentReference
 */
export const DocumentReference = new DocumentReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeSpatialInfo$Type extends MessageType<NodeSpatialInfo> {
    constructor() {
        super("NodeSpatialInfo", [
            { no: 1, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spatialInfo", kind: "message", T: () => SpatialInfo }
        ]);
    }
    create(value?: PartialMessage<NodeSpatialInfo>): NodeSpatialInfo {
        const message = { roomId: "", id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeSpatialInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeSpatialInfo): NodeSpatialInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string roomId */ 1:
                    message.roomId = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* SpatialInfo spatialInfo */ 3:
                    message.spatialInfo = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.spatialInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeSpatialInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string roomId = 1; */
        if (message.roomId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.roomId);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* SpatialInfo spatialInfo = 3; */
        if (message.spatialInfo)
            SpatialInfo.internalBinaryWrite(message.spatialInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NodeSpatialInfo
 */
export const NodeSpatialInfo = new NodeSpatialInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeList$Type extends MessageType<NodeList> {
    constructor() {
        super("NodeList", [
            { no: 1, name: "SpatialInfos", kind: "message", jsonName: "SpatialInfos", repeat: 1 /*RepeatType.PACKED*/, T: () => NodeSpatialInfo },
            { no: 2, name: "userKey", kind: "message", T: () => UserKey }
        ]);
    }
    create(value?: PartialMessage<NodeList>): NodeList {
        const message = { spatialInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeList): NodeList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated NodeSpatialInfo SpatialInfos = 1 [json_name = "SpatialInfos"];*/ 1:
                    message.spatialInfos.push(NodeSpatialInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* UserKey userKey */ 2:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated NodeSpatialInfo SpatialInfos = 1 [json_name = "SpatialInfos"]; */
        for (let i = 0; i < message.spatialInfos.length; i++)
            NodeSpatialInfo.internalBinaryWrite(message.spatialInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* UserKey userKey = 2; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NodeList
 */
export const NodeList = new NodeList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Link$Type extends MessageType<Link> {
    constructor() {
        super("Link", [
            { no: 1, name: "source", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "target", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "createdFrom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "createdBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "updatedBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "userKey", kind: "message", T: () => UserKey }
        ]);
    }
    create(value?: PartialMessage<Link>): Link {
        const message = { source: 0, target: 0, id: "", name: "", data: "", roomId: "", createdFrom: "", createdBy: "", updatedBy: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Link>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Link): Link {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 source */ 1:
                    message.source = reader.int32();
                    break;
                case /* int32 target */ 2:
                    message.target = reader.int32();
                    break;
                case /* string id */ 3:
                    message.id = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string data */ 5:
                    message.data = reader.string();
                    break;
                case /* string roomId */ 6:
                    message.roomId = reader.string();
                    break;
                case /* string createdFrom */ 7:
                    message.createdFrom = reader.string();
                    break;
                case /* string createdBy */ 8:
                    message.createdBy = reader.string();
                    break;
                case /* string updatedBy */ 9:
                    message.updatedBy = reader.string();
                    break;
                case /* UserKey userKey */ 10:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Link, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 source = 1; */
        if (message.source !== 0)
            writer.tag(1, WireType.Varint).int32(message.source);
        /* int32 target = 2; */
        if (message.target !== 0)
            writer.tag(2, WireType.Varint).int32(message.target);
        /* string id = 3; */
        if (message.id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.id);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string data = 5; */
        if (message.data !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.data);
        /* string roomId = 6; */
        if (message.roomId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.roomId);
        /* string createdFrom = 7; */
        if (message.createdFrom !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdFrom);
        /* string createdBy = 8; */
        if (message.createdBy !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.createdBy);
        /* string updatedBy = 9; */
        if (message.updatedBy !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.updatedBy);
        /* UserKey userKey = 10; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Link
 */
export const Link = new Link$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LinkList$Type extends MessageType<LinkList> {
    constructor() {
        super("LinkList", [
            { no: 1, name: "links", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Link }
        ]);
    }
    create(value?: PartialMessage<LinkList>): LinkList {
        const message = { links: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LinkList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LinkList): LinkList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Link links */ 1:
                    message.links.push(Link.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LinkList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Link links = 1; */
        for (let i = 0; i < message.links.length; i++)
            Link.internalBinaryWrite(message.links[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LinkList
 */
export const LinkList = new LinkList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GraphViewData$Type extends MessageType<GraphViewData> {
    constructor() {
        super("GraphViewData", [
            { no: 1, name: "nodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Node },
            { no: 2, name: "links", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Link },
            { no: 3, name: "spatialInfo", kind: "message", T: () => SpatialInfo }
        ]);
    }
    create(value?: PartialMessage<GraphViewData>): GraphViewData {
        const message = { nodes: [], links: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GraphViewData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GraphViewData): GraphViewData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Node nodes */ 1:
                    message.nodes.push(Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Link links */ 2:
                    message.links.push(Link.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* SpatialInfo spatialInfo */ 3:
                    message.spatialInfo = SpatialInfo.internalBinaryRead(reader, reader.uint32(), options, message.spatialInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GraphViewData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Node nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            Node.internalBinaryWrite(message.nodes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Link links = 2; */
        for (let i = 0; i < message.links.length; i++)
            Link.internalBinaryWrite(message.links[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* SpatialInfo spatialInfo = 3; */
        if (message.spatialInfo)
            SpatialInfo.internalBinaryWrite(message.spatialInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GraphViewData
 */
export const GraphViewData = new GraphViewData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientActions$Type extends MessageType<ClientActions> {
    constructor() {
        super("ClientActions", [
            { no: 1, name: "userKey", kind: "message", T: () => UserKey },
            { no: 2, name: "clickedNodes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hoveredNodes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "fromView", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClientActions>): ClientActions {
        const message = { clickedNodes: [], hoveredNodes: [], fromView: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientActions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientActions): ClientActions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UserKey userKey */ 1:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                case /* repeated int32 clickedNodes */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.clickedNodes.push(reader.int32());
                    else
                        message.clickedNodes.push(reader.int32());
                    break;
                case /* repeated int32 hoveredNodes */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.hoveredNodes.push(reader.int32());
                    else
                        message.hoveredNodes.push(reader.int32());
                    break;
                case /* string fromView */ 5:
                    message.fromView = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientActions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UserKey userKey = 1; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 clickedNodes = 2; */
        if (message.clickedNodes.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.clickedNodes.length; i++)
                writer.int32(message.clickedNodes[i]);
            writer.join();
        }
        /* repeated int32 hoveredNodes = 3; */
        if (message.hoveredNodes.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.hoveredNodes.length; i++)
                writer.int32(message.hoveredNodes[i]);
            writer.join();
        }
        /* string fromView = 5; */
        if (message.fromView !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.fromView);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientActions
 */
export const ClientActions = new ClientActions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackerInfo$Type extends MessageType<TrackerInfo> {
    constructor() {
        super("TrackerInfo", [
            { no: 1, name: "trackerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Position },
            { no: 3, name: "rotation", kind: "message", T: () => Rotation }
        ]);
    }
    create(value?: PartialMessage<TrackerInfo>): TrackerInfo {
        const message = { trackerId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackerInfo): TrackerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trackerId */ 1:
                    message.trackerId = reader.string();
                    break;
                case /* Position position */ 2:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* Rotation rotation */ 3:
                    message.rotation = Rotation.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trackerId = 1; */
        if (message.trackerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trackerId);
        /* Position position = 2; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Rotation rotation = 3; */
        if (message.rotation)
            Rotation.internalBinaryWrite(message.rotation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrackerInfo
 */
export const TrackerInfo = new TrackerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HighlightedList$Type extends MessageType<HighlightedList> {
    constructor() {
        super("HighlightedList", [
            { no: 1, name: "highlighted", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HighlightedList>): HighlightedList {
        const message = { highlighted: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HighlightedList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HighlightedList): HighlightedList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 highlighted */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.highlighted.push(reader.int32());
                    else
                        message.highlighted.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HighlightedList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 highlighted = 1; */
        if (message.highlighted.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.highlighted.length; i++)
                writer.int32(message.highlighted[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HighlightedList
 */
export const HighlightedList = new HighlightedList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerNodesStatus$Type extends MessageType<ServerNodesStatus> {
    constructor() {
        super("ServerNodesStatus", [
            { no: 1, name: "hightlighted", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => HighlightedList } }
        ]);
    }
    create(value?: PartialMessage<ServerNodesStatus>): ServerNodesStatus {
        const message = { hightlighted: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerNodesStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerNodesStatus): ServerNodesStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, HighlightedList> hightlighted */ 1:
                    this.binaryReadMap1(message.hightlighted, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ServerNodesStatus["hightlighted"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ServerNodesStatus["hightlighted"] | undefined, val: ServerNodesStatus["hightlighted"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = HighlightedList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ServerNodesStatus.hightlighted");
            }
        }
        map[key ?? ""] = val ?? HighlightedList.create();
    }
    internalBinaryWrite(message: ServerNodesStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, HighlightedList> hightlighted = 1; */
        for (let k of Object.keys(message.hightlighted)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            HighlightedList.internalBinaryWrite(message.hightlighted[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerNodesStatus
 */
export const ServerNodesStatus = new ServerNodesStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmptyMessage$Type extends MessageType<EmptyMessage> {
    constructor() {
        super("EmptyMessage", [
            { no: 1, name: "isRecieved", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EmptyMessage>): EmptyMessage {
        const message = { isRecieved: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EmptyMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmptyMessage): EmptyMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isRecieved */ 1:
                    message.isRecieved = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmptyMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isRecieved = 1; */
        if (message.isRecieved !== false)
            writer.tag(1, WireType.Varint).bool(message.isRecieved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EmptyMessage
 */
export const EmptyMessage = new EmptyMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitialRequest$Type extends MessageType<InitialRequest> {
    constructor() {
        super("InitialRequest", [
            { no: 1, name: "RequestedViewType", kind: "enum", jsonName: "RequestedViewType", T: () => ["InitialRequest.ClientViewType", InitialRequest_ClientViewType] },
            { no: 2, name: "userKey", kind: "message", T: () => UserKey }
        ]);
    }
    create(value?: PartialMessage<InitialRequest>): InitialRequest {
        const message = { requestedViewType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InitialRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitialRequest): InitialRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* InitialRequest.ClientViewType RequestedViewType = 1 [json_name = "RequestedViewType"];*/ 1:
                    message.requestedViewType = reader.int32();
                    break;
                case /* UserKey userKey */ 2:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitialRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* InitialRequest.ClientViewType RequestedViewType = 1 [json_name = "RequestedViewType"]; */
        if (message.requestedViewType !== 0)
            writer.tag(1, WireType.Varint).int32(message.requestedViewType);
        /* UserKey userKey = 2; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InitialRequest
 */
export const InitialRequest = new InitialRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitialGraphData$Type extends MessageType<InitialGraphData> {
    constructor() {
        super("InitialGraphData", [
            { no: 1, name: "graphViewData", kind: "message", T: () => GraphViewData },
            { no: 2, name: "nodesStatus", kind: "message", T: () => ServerNodesStatus }
        ]);
    }
    create(value?: PartialMessage<InitialGraphData>): InitialGraphData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InitialGraphData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitialGraphData): InitialGraphData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* GraphViewData graphViewData */ 1:
                    message.graphViewData = GraphViewData.internalBinaryRead(reader, reader.uint32(), options, message.graphViewData);
                    break;
                case /* ServerNodesStatus nodesStatus */ 2:
                    message.nodesStatus = ServerNodesStatus.internalBinaryRead(reader, reader.uint32(), options, message.nodesStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitialGraphData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* GraphViewData graphViewData = 1; */
        if (message.graphViewData)
            GraphViewData.internalBinaryWrite(message.graphViewData, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ServerNodesStatus nodesStatus = 2; */
        if (message.nodesStatus)
            ServerNodesStatus.internalBinaryWrite(message.nodesStatus, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InitialGraphData
 */
export const InitialGraphData = new InitialGraphData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Room$Type extends MessageType<Room> {
    constructor() {
        super("Room", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "users", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserInfo }
        ]);
    }
    create(value?: PartialMessage<Room>): Room {
        const message = { id: "", users: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Room>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Room): Room {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated UserInfo users */ 2:
                    message.users.push(UserInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Room, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated UserInfo users = 2; */
        for (let i = 0; i < message.users.length; i++)
            UserInfo.internalBinaryWrite(message.users[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Room
 */
export const Room = new Room$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomList$Type extends MessageType<RoomList> {
    constructor() {
        super("RoomList", [
            { no: 1, name: "rooms", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Room }
        ]);
    }
    create(value?: PartialMessage<RoomList>): RoomList {
        const message = { rooms: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomList): RoomList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Room rooms */ 1:
                    message.rooms.push(Room.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Room rooms = 1; */
        for (let i = 0; i < message.rooms.length; i++)
            Room.internalBinaryWrite(message.rooms[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomList
 */
export const RoomList = new RoomList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinResponse$Type extends MessageType<JoinResponse> {
    constructor() {
        super("JoinResponse", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JoinResponse>): JoinResponse {
        const message = { error: "", msg: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JoinResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinResponse): JoinResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                case /* string msg */ 2:
                    message.msg = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        /* string msg = 2; */
        if (message.msg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.msg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message JoinResponse
 */
export const JoinResponse = new JoinResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerGraphStatus$Type extends MessageType<ServerGraphStatus> {
    constructor() {
        super("ServerGraphStatus", [
            { no: 1, name: "nodesStatus", kind: "message", T: () => ServerNodesStatus },
            { no: 2, name: "initialGraphData", kind: "message", T: () => InitialGraphData }
        ]);
    }
    create(value?: PartialMessage<ServerGraphStatus>): ServerGraphStatus {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerGraphStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerGraphStatus): ServerGraphStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ServerNodesStatus nodesStatus */ 1:
                    message.nodesStatus = ServerNodesStatus.internalBinaryRead(reader, reader.uint32(), options, message.nodesStatus);
                    break;
                case /* InitialGraphData initialGraphData */ 2:
                    message.initialGraphData = InitialGraphData.internalBinaryRead(reader, reader.uint32(), options, message.initialGraphData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerGraphStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ServerNodesStatus nodesStatus = 1; */
        if (message.nodesStatus)
            ServerNodesStatus.internalBinaryWrite(message.nodesStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* InitialGraphData initialGraphData = 2; */
        if (message.initialGraphData)
            InitialGraphData.internalBinaryWrite(message.initialGraphData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerGraphStatus
 */
export const ServerGraphStatus = new ServerGraphStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Document$Type extends MessageType<Document> {
    constructor() {
        super("Document", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "author", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fileName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Document>): Document {
        const message = { id: "", title: "", date: "", author: "", content: "", fileName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Document>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Document): Document {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string date */ 3:
                    message.date = reader.string();
                    break;
                case /* string author */ 4:
                    message.author = reader.string();
                    break;
                case /* string content */ 5:
                    message.content = reader.string();
                    break;
                case /* string fileName */ 6:
                    message.fileName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Document, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string date = 3; */
        if (message.date !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.date);
        /* string author = 4; */
        if (message.author !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.author);
        /* string content = 5; */
        if (message.content !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.content);
        /* string fileName = 6; */
        if (message.fileName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fileName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Document
 */
export const Document = new Document$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentList$Type extends MessageType<DocumentList> {
    constructor() {
        super("DocumentList", [
            { no: 1, name: "documents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Document }
        ]);
    }
    create(value?: PartialMessage<DocumentList>): DocumentList {
        const message = { documents: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DocumentList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentList): DocumentList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Document documents */ 1:
                    message.documents.push(Document.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Document documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            Document.internalBinaryWrite(message.documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentList
 */
export const DocumentList = new DocumentList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdList$Type extends MessageType<IdList> {
    constructor() {
        super("IdList", [
            { no: 1, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<IdList>): IdList {
        const message = { ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IdList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdList): IdList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ids */ 1:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string ids = 1; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IdList
 */
export const IdList = new IdList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentState$Type extends MessageType<DocumentState> {
    constructor() {
        super("DocumentState", [
            { no: 1, name: "documentStates", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => IdList } }
        ]);
    }
    create(value?: PartialMessage<DocumentState>): DocumentState {
        const message = { documentStates: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DocumentState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentState): DocumentState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, IdList> documentStates */ 1:
                    this.binaryReadMap1(message.documentStates, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: DocumentState["documentStates"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentState["documentStates"] | undefined, val: DocumentState["documentStates"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = IdList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field DocumentState.documentStates");
            }
        }
        map[key ?? ""] = val ?? IdList.create();
    }
    internalBinaryWrite(message: DocumentState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, IdList> documentStates = 1; */
        for (let k of Object.keys(message.documentStates)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            IdList.internalBinaryWrite(message.documentStates[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DocumentState
 */
export const DocumentState = new DocumentState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestById$Type extends MessageType<RequestById> {
    constructor() {
        super("RequestById", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userKey", kind: "message", T: () => UserKey }
        ]);
    }
    create(value?: PartialMessage<RequestById>): RequestById {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestById>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestById): RequestById {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* UserKey userKey */ 2:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestById, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* UserKey userKey = 2; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RequestById
 */
export const RequestById = new RequestById$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoardcastMessage$Type extends MessageType<BoardcastMessage> {
    constructor() {
        super("BoardcastMessage", [
            { no: 1, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userKey", kind: "message", T: () => UserKey },
            { no: 3, name: "action", kind: "enum", T: () => ["BoardcastMessage.Action", BoardcastMessage_Action] }
        ]);
    }
    create(value?: PartialMessage<BoardcastMessage>): BoardcastMessage {
        const message = { msg: "", action: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BoardcastMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoardcastMessage): BoardcastMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msg */ 1:
                    message.msg = reader.string();
                    break;
                case /* UserKey userKey */ 2:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                case /* BoardcastMessage.Action action */ 3:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoardcastMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msg = 1; */
        if (message.msg !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msg);
        /* UserKey userKey = 2; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* BoardcastMessage.Action action = 3; */
        if (message.action !== 0)
            writer.tag(3, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BoardcastMessage
 */
export const BoardcastMessage = new BoardcastMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplayMessage$Type extends MessageType<ReplayMessage> {
    constructor() {
        super("ReplayMessage", [
            { no: 1, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userKey", kind: "message", T: () => UserKey }
        ]);
    }
    create(value?: PartialMessage<ReplayMessage>): ReplayMessage {
        const message = { msg: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReplayMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReplayMessage): ReplayMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msg */ 1:
                    message.msg = reader.string();
                    break;
                case /* UserKey userKey */ 2:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReplayMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msg = 1; */
        if (message.msg !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msg);
        /* UserKey userKey = 2; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReplayMessage
 */
export const ReplayMessage = new ReplayMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplayRecord$Type extends MessageType<ReplayRecord> {
    constructor() {
        super("ReplayRecord", [
            { no: 1, name: "userKey", kind: "message", T: () => UserKey }
        ]);
    }
    create(value?: PartialMessage<ReplayRecord>): ReplayRecord {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReplayRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReplayRecord): ReplayRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UserKey userKey */ 1:
                    message.userKey = UserKey.internalBinaryRead(reader, reader.uint32(), options, message.userKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReplayRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UserKey userKey = 1; */
        if (message.userKey)
            UserKey.internalBinaryWrite(message.userKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReplayRecord
 */
export const ReplayRecord = new ReplayRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplayList$Type extends MessageType<ReplayList> {
    constructor() {
        super("ReplayList", [
            { no: 1, name: "records", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReplayRecord }
        ]);
    }
    create(value?: PartialMessage<ReplayList>): ReplayList {
        const message = { records: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReplayList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReplayList): ReplayList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ReplayRecord records */ 1:
                    message.records.push(ReplayRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReplayList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ReplayRecord records = 1; */
        for (let i = 0; i < message.records.length; i++)
            ReplayRecord.internalBinaryWrite(message.records[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReplayList
 */
export const ReplayList = new ReplayList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebRTCOffer$Type extends MessageType<WebRTCOffer> {
    constructor() {
        super("WebRTCOffer", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WebRTCOffer>): WebRTCOffer {
        const message = { data: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WebRTCOffer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebRTCOffer): WebRTCOffer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebRTCOffer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WebRTCOffer
 */
export const WebRTCOffer = new WebRTCOffer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebRTCAnswer$Type extends MessageType<WebRTCAnswer> {
    constructor() {
        super("WebRTCAnswer", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WebRTCAnswer>): WebRTCAnswer {
        const message = { data: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WebRTCAnswer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebRTCAnswer): WebRTCAnswer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebRTCAnswer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WebRTCAnswer
 */
export const WebRTCAnswer = new WebRTCAnswer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimelineData$Type extends MessageType<TimelineData> {
    constructor() {
        super("TimelineData", [
            { no: 1, name: "data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => IdList } }
        ]);
    }
    create(value?: PartialMessage<TimelineData>): TimelineData {
        const message = { data: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimelineData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimelineData): TimelineData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, IdList> data */ 1:
                    this.binaryReadMap1(message.data, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TimelineData["data"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TimelineData["data"] | undefined, val: TimelineData["data"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = IdList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field TimelineData.data");
            }
        }
        map[key ?? ""] = val ?? IdList.create();
    }
    internalBinaryWrite(message: TimelineData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, IdList> data = 1; */
        for (let k of Object.keys(message.data)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            IdList.internalBinaryWrite(message.data[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TimelineData
 */
export const TimelineData = new TimelineData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserKey$Type extends MessageType<UserKey> {
    constructor() {
        super("UserKey", [
            { no: 1, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["UserInfo.ClientType", UserInfo_ClientType] },
            { no: 4, name: "viewType", kind: "enum", T: () => ["InitialRequest.ClientViewType", InitialRequest_ClientViewType] }
        ]);
    }
    create(value?: PartialMessage<UserKey>): UserKey {
        const message = { userId: "", roomId: "", type: 0, viewType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserKey): UserKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string userId */ 1:
                    message.userId = reader.string();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* UserInfo.ClientType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* InitialRequest.ClientViewType viewType */ 4:
                    message.viewType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string userId = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* UserInfo.ClientType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* InitialRequest.ClientViewType viewType = 4; */
        if (message.viewType !== 0)
            writer.tag(4, WireType.Varint).int32(message.viewType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserKey
 */
export const UserKey = new UserKey$Type();
/**
 * @generated ServiceType for protobuf service EchoService
 */
export const EchoService = new ServiceType("EchoService", [
    { name: "GetInitialGraphData", options: {}, I: InitialRequest, O: InitialGraphData },
    { name: "UpdateNodesStatus", options: {}, I: ClientActions, O: ServerNodesStatus },
    { name: "GetGraphData", serverStreaming: true, options: {}, I: RequestById, O: GraphViewData },
    { name: "GetNodes", serverStreaming: true, options: {}, I: InitialRequest, O: NodeList },
    { name: "GetLinks", serverStreaming: true, options: {}, I: RequestById, O: LinkList },
    { name: "GetNodesStatus", serverStreaming: true, options: {}, I: RequestById, O: ServerNodesStatus },
    { name: "GetAllUsers", serverStreaming: true, options: {}, I: EmptyMessage, O: UserList },
    { name: "GetAllUsersByRoomId", serverStreaming: true, options: {}, I: RequestById, O: UserList },
    { name: "GetAllRooms", serverStreaming: true, options: {}, I: EmptyMessage, O: RoomList },
    { name: "Join", options: {}, I: UserInfo, O: UserInfo },
    { name: "Leave", options: {}, I: UserInfo, O: EmptyMessage },
    { name: "UpdateUserStatus", options: {}, I: UserInfo, O: EmptyMessage },
    { name: "AddNode", options: {}, I: Node, O: Node },
    { name: "UpdateNode", options: {}, I: Node, O: EmptyMessage },
    { name: "RemoveNode", options: {}, I: Node, O: EmptyMessage },
    { name: "MergeNodes", options: {}, I: NodeList, O: EmptyMessage },
    { name: "AddLink", options: {}, I: Link, O: EmptyMessage },
    { name: "UpdateLink", options: {}, I: Link, O: EmptyMessage },
    { name: "RemoveLink", options: {}, I: Link, O: EmptyMessage },
    { name: "GetDoument", options: {}, I: RequestById, O: Document },
    { name: "UpdateDocumentState", options: {}, I: RequestById, O: EmptyMessage },
    { name: "GetAllDouments", serverStreaming: true, options: {}, I: RequestById, O: DocumentList },
    { name: "GetDocumentState", serverStreaming: true, options: {}, I: RequestById, O: DocumentState },
    { name: "SendBoardcastMessage", options: {}, I: BoardcastMessage, O: EmptyMessage },
    { name: "GetBoardcastMessage", serverStreaming: true, options: {}, I: RequestById, O: BoardcastMessage },
    { name: "GetReplayList", options: {}, I: RequestById, O: ReplayList },
    { name: "GetReplay", serverStreaming: true, options: {}, I: ReplayMessage, O: ReplayMessage },
    { name: "SetWebRTCOffer", options: {}, I: RequestById, O: EmptyMessage },
    { name: "GetWebRTCOffer", options: {}, I: RequestById, O: WebRTCOffer },
    { name: "GetWebRTCOfferStream", serverStreaming: true, options: {}, I: RequestById, O: WebRTCOffer },
    { name: "SetWebRTCAnswer", options: {}, I: RequestById, O: EmptyMessage },
    { name: "GetWebRTCAnswer", options: {}, I: RequestById, O: WebRTCAnswer },
    { name: "GetWebRTCAnswerStream", serverStreaming: true, options: {}, I: RequestById, O: WebRTCAnswer },
    { name: "GetTrackerInfoStream", serverStreaming: true, options: {}, I: RequestById, O: TrackerInfo },
    { name: "GetTimelineDataStream", serverStreaming: true, options: {}, I: RequestById, O: TimelineData }
]);
